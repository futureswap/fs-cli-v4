/**
 * Given an exchange, recovers the list of trading positions open as of a specific block number.
 *
 * As positions are stored in a map in the `Exchange` contract, we can not just iterate over all the
 * positions.  Instead we read `ChangePosition` events generated by the exchange and recover the
 * active list based on that.
 *
 * Both v4 and v4.1 use this code to fetch positions.
 */

import { default as _ } from "lodash";
import { tryNTimes } from "utils";

export enum PositionState {
  Open,
  Closed,
}

export class Position {
  constructor(
    /// Block number where we observed latest action for this position.
    public block: number,
    /// Transaction number within the `block`, number where we observed latest action for this
    //position.
    public transaction: number,
    /// State observed in block `lastAction`.
    public state: PositionState
  ) {}
}

/**
 * Abstracts the process of fetching events for different deployment types.
 */
export type GetEvents<Event> = (
  fromBlock: number,
  toBlock: number
) => Promise<Event[]>;

/**
 * Given an event returned by `GetEvents<Event>`, returns it's internal details.
 *
 * Returning `undefined` ignores the event.
 */
export type UnpackEvent<Event> = (
  event: Event
) => [string, number, number, PositionState] | undefined;

/**
 * Maps a position to the latest state available about this position.
 */
export class Positions {
  /**
   * First block that has been already processed, and is contained in `positions`.
   * `undefined` means we have not processed any blocks yet.
   */
  firstProcessedBlock: undefined | number;

  /**
   * Last block that has been already processed, and is contained in `positions`.
   * `undefined` means we have not processed any blocks yet.
   */
  lastProcessedBlock: undefined | number;

  constructor(
    private exchangeLaunchBlock: number,
    public positions: {
      [address: string]: Position;
    } = {}
  ) {
    this.firstProcessedBlock = undefined;
    this.lastProcessedBlock = undefined;
  }

  public historyIsComplete(): boolean {
    return (
      this.firstProcessedBlock !== undefined &&
      this.firstProcessedBlock <= this.exchangeLaunchBlock
    );
  }

  public historyBlocksLeft(): number {
    return this.firstProcessedBlock === undefined
      ? 0
      : this.firstProcessedBlock - this.exchangeLaunchBlock;
  }

  /**
   * Fetches `blocks` blocks of history and updates `positions` with the corresponding events.
   */
  public async fetchHistory<Event>(
    blocks: number,
    getCurrentBlock: () => Promise<number>,
    getEvents: GetEvents<Event>,
    unpackEvent: UnpackEvent<Event>
  ): Promise<void> {
    const { firstProcessedBlock, exchangeLaunchBlock } = this;

    let fromBlock: number;
    let toBlock: number;

    if (firstProcessedBlock === undefined) {
      const currentBlock = await getCurrentBlock();
      fromBlock = Math.max(currentBlock - blocks, exchangeLaunchBlock);
      toBlock = currentBlock;
    } else {
      fromBlock = Math.max(
        firstProcessedBlock - blocks - 1,
        exchangeLaunchBlock
      );
      toBlock = firstProcessedBlock - 1;
    }

    await this.getEventsFor(fromBlock, toBlock, getEvents, unpackEvent);

    this.firstProcessedBlock = fromBlock;
    if (this.lastProcessedBlock === undefined) {
      this.lastProcessedBlock = toBlock;
    }
  }

  /**
   * Fetches blocks since the last call and up until the block returned by `getCurrentBlock()`.
   * Updates `positions` with the corresponding events.  If this is the first call, just records
   * `getCurrentBlock()` result as the next starting point.
   */
  public async fetchNew<Event>(
    blocks: number,
    getCurrentBlock: () => Promise<number>,
    getEvents: GetEvents<Event>,
    unpackEvent: UnpackEvent<Event>
  ): Promise<void> {
    const { lastProcessedBlock } = this;

    let toBlock = await getCurrentBlock();

    if (lastProcessedBlock === undefined) {
      // Include current block in the next call to `fetchHistory()` - it will start from the block
      // preceding `firstProcessedBlock`.
      this.firstProcessedBlock = toBlock + 1;
      this.lastProcessedBlock = toBlock;
      return;
    }

    const fromBlock = lastProcessedBlock + 1;

    if (fromBlock > toBlock) {
      // No new blocks.
      return;
    }

    toBlock = Math.min(fromBlock + blocks - 1, toBlock);

    await this.getEventsFor(fromBlock, toBlock, getEvents, unpackEvent);

    this.lastProcessedBlock = toBlock;
  }

  private async getEventsFor<Event>(
    fromBlock: number,
    toBlock: number,
    getEvents: GetEvents<Event>,
    unpackEvent: UnpackEvent<Event>
  ): Promise<void> {
    const { positions } = this;

    const events = await tryNTimes(3, () => getEvents(fromBlock, toBlock));

    for (const event of events) {
      const unpacked = unpackEvent(event);
      if (unpacked === undefined) {
        continue;
      }
      const [address, block, transaction, state] = unpacked;

      const position = positions[address];
      if (position === undefined) {
        positions[address] = new Position(block, transaction, state);
        continue;
      }

      if (
        position.block > block ||
        (position.block == block && position.transaction >= transaction)
      ) {
        continue;
      }

      position.block = block;
      position.transaction = transaction;
      position.state = state;
    }
  }

  public getOpen(): string[] {
    const { positions } = this;

    return Object.entries(positions)
      .filter(([_address, info]) => info.state == PositionState.Open)
      .map(([address, _info]) => address);
  }
}
